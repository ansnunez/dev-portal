<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Gossip · Zilliqa Developer Portal</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A `RumorManager` library is available in the Zilliqa core to support message gossiping between nodes."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Gossip · Zilliqa Developer Portal"/><meta property="og:type" content="website"/><meta property="og:url" content="https://ansnunez.github.io/dev-portal/"/><meta property="og:description" content="A `RumorManager` library is available in the Zilliqa core to support message gossiping between nodes."/><meta property="og:image" content="https://ansnunez.github.io/dev-portal/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://ansnunez.github.io/dev-portal/img/docusaurus.png"/><link rel="shortcut icon" href="/dev-portal/img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/dev-portal/js/scrollSpy.js"></script><link rel="stylesheet" href="/dev-portal/css/main.css"/><script src="/dev-portal/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/dev-portal/en"><img class="logo" src="/dev-portal/img/zilliqa-logo_1zilliqa-logo.png" alt="Zilliqa Developer Portal"/><h2 class="headerTitleWithLogo">Zilliqa Developer Portal</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/dev-portal/docs/en/basics-intro-blockchain" target="_self">Basics</a></li><li class=""><a href="/dev-portal/docs/en/dev-started-introduction" target="_self">Developers</a></li><li class=""><a href="/dev-portal/docs/en/mining-general-info" target="_self">Miners</a></li><li class=""><a href="/dev-portal/docs/en/staking-getting-started" target="_self">Exchanges</a></li><li class=""><a href="/dev-portal/docs/en/contribute-buildzil" target="_self">Contributors</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/dev-portal/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/dev-portal/docs/zh-CN/core-network">中文</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Gossip</h1></header><article><div><span><p>A <code>RumorManager</code> library is available in the Zilliqa core to support message gossiping between nodes.</p>
<h2><a class="anchor" aria-hidden="true" id="overview"></a><a href="#overview" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview</h2>
<ul>
<li>The goal is to provide an alternative communication method to broadcasting, particularly in large-scale clusters.</li>
<li>The broadcasting implemented in <code>P2PComm::SendBroadcastMessage</code> is resource-hungry; it sends <code>O(n^2)</code> messages, requires a lot of threads, and opens too many TCP connections.</li>
<li>The gossip algorithm, described in detail in this <a href="https://zoo.cs.yale.edu/classes/cs426/2013/bib/karp00randomized.pdf">paper</a>, provides a method to spread a message in <code>O(logn)</code> rounds and <code>O(ln(ln(n)))</code> rumor messages (where <code>n</code> is the number of peers participating in the gossip).</li>
<li><code>RumorManager</code> plays the role of managing all the gossips/rumors and their states.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="interfaces"></a><a href="#interfaces" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interfaces</h2>
<p>The following interfaces are exposed for a node to enable gossiping messages in the network.</p>
<h3><a class="anchor" aria-hidden="true" id="initializerumormanager"></a><a href="#initializerumormanager" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>InitializeRumorManager</h3>
<p>Every node in the network intializes <code>RumorManager</code> with the list of peers from their own shard or committee at the start of a new DS epoch (or after a successful view change).</p>
<p>Initialization involves the following:</p>
<ul>
<li>Storing peer list</li>
<li>Storing public keys of the peers in the peer list, the DS committee members, and lookup nodes</li>
<li>Storing the node's own peer information and key pair</li>
<li>Starting of rounds (that runs a loop every <code>ROUND_TIME_IN_MS</code> ms), which includes:
<ul>
<li>Checking the state of every rumor in <code>RumorHolder</code> and sending to <code>MAX_NEIGHBORS_PER_ROUND</code> random peers (if the rumor is not old enough).</li>
<li><code>RumorHolder</code> monitors/changes the state of each rumor it holds using the Median Counter algorithm (as explained in Section 3 of the whitepaper) for every round.</li>
</ul></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="spreadrumor"></a><a href="#spreadrumor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SpreadRumor</h3>
<p>This enables the node to initiate the rumor to be gossiped with its peer list. It will basically add the rumor to <code>RumorHolder</code>, which in turn manages its states and further gossiping.</p>
<h3><a class="anchor" aria-hidden="true" id="spreadforeignrumor"></a><a href="#spreadforeignrumor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SpreadForeignRumor</h3>
<p>This enables the node to initiate spreading of the rumor received from a node that is not part of its peer list (hence, &quot;foreign&quot;). It verifies the sender node against all the public keys stored during the initialization of <code>RumorManager</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="stoprounds"></a><a href="#stoprounds" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>StopRounds</h3>
<p>Stops the gossip round, thereby stopping the gossiping of rumors to peers.</p>
<h2><a class="anchor" aria-hidden="true" id="rumor-state-machine"></a><a href="#rumor-state-machine" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rumor State Machine</h2>
<p>The rumor state machine is managed by <code>RumorHolder</code>.</p>
<p>Every rumor will be in one of following states at any time:</p>
<ul>
<li><code>NEW</code>: The peer <code>v</code> knows <code>r</code> and <code>counter(v,r) = m</code> (age/round)</li>
<li><code>KNOWN</code>: Cooling state; stay in this state for <code>m_maxRounds</code> rounds, and participate in rumor spreading</li>
<li><code>OLD</code>: Final state; member stops participating in rumor spreading</li>
</ul>
<p>Every rumor starts in the <code>NEW</code> state. It either stays in this state, or moves on to <code>KNOWN</code> or <code>OLD</code> state immediately or in successive rounds based on the algorithm mentioned in the whitepaper. Every rumor is tied up with the round (consider it as the rumor age).</p>
<p>A rumor is configured to stay in <code>NEW</code> and <code>KNOWN</code> state for a maximum of <code>&lt;MAX_ROUNDS_IN_BSTATE&gt;</code> and <code>&lt;MAX_ROUNDS_IN_CSTATE&gt;</code>, respectively.
The total rounds is configured to not exceed <code>&lt;MAX_TOTAL_ROUNDS&gt;</code>, after which the rumor is marked as <code>OLD</code>. These settings are found in the node's constants file, like thus:</p>
<pre><code class="hljs css language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">gossip_custom_rounds</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">MAX_ROUNDS_IN_BSTATE</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">MAX_ROUNDS_IN_BSTATE</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">MAX_ROUNDS_IN_CSTATE</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">MAX_ROUNDS_IN_CSTATE</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">MAX_TOTAL_ROUNDS</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">MAX_TOTAL_ROUNDS</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">gossip_custom_rounds</span>&gt;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="gossip-message-format"></a><a href="#gossip-message-format" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Gossip Message Format</h2>
<table>
<thead>
<tr><th>START_BYTE_GOSSIP (0x33)</th><th>HDR</th><th>GOSSIP_MSGTYPE</th><th>GOSSIP_ROUND</th><th>GOSSIP_SNDR_PORT</th><th>PUB_KEY_SIZE</th><th>SIGNATURE</th><th>Payload Message</th></tr>
</thead>
<tbody>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="optimized-pull-push-mechanism"></a><a href="#optimized-pull-push-mechanism" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optimized Pull-Push Mechanism</h2>
<p><code>GOSSIP_MSGTYPE</code> can refer to any of the following:</p>
<ul>
<li><code>PUSH (0x01)</code>: The response to a <code>PULL</code> request. The payload contains the raw message. It is sent out to the requesting peer.</li>
<li><code>PULL (0x02)</code>: The request for the raw message for a given hash. The payload contains the hash. It is sent out in response to the node who sent <code>LAZY_PUSH</code> or <code>LAZY_PULL</code>.</li>
<li><code>EMPTY_PUSH (0x03)</code>: This is sent out at every round to random neighbors if the node does not have any active rumors in its store. It indicates asking for any rumors from the node's neighbors. The payload contains unused dummy data.</li>
<li><code>EMPTY_PULL (0x04)</code>: This is sent out to the sender of <code>EMPTY_PULL</code> or <code>LAZY_PULL</code> to indicate that it doesn't have any active rumors either. The payload contains unused dummy data.</li>
<li><code>FORWARD (0x05)</code>: A special type that indicates that the message being sent out is from a foreign peer. This means the sender does not belong to the current shard or committee. Normally it is sent from a lookup to a shard or DS committee node, or between a shard node and DS committee node (in either direction).</li>
<li><code>LAZY_PUSH (0x06)</code>: This is sent out at every round to random neighbors for each active rumor in its store. The payload contains the hash of the raw message intended to be gossiped.</li>
<li><code>LAZY_PULL (0x07)</code>: The response to the sender if it is the first time that sender has sent a <code>LAZY_PUSH</code>/<code>EMPTY_PUSH</code> message during this round. The payload contains the hash of the raw message.</li>
</ul>
<blockquote>
<p><strong>NOTE:</strong> Every gossip message is signed, and the signature is verified before being accepted.</p>
</blockquote>
<p>Through the messages above, the standard Push-Pull mechanism is optimized by gossiping the hashes using <code>EMPTY_*</code> and <code>LAZY_*</code> and fetching the actual raw messages using <code>PUSH</code> and <code>PULL</code>.</p>
<p>So, <code>LAZY_PUSH</code> and <code>LAZY_PULL</code> are the backbone for gossiping of hashes, and are the only gossip messages that have a valid <code>GOSSIP_ROUND</code> for their underlying rumor (i.e., the hash). For the other message types, <code>GOSSIP_ROUND</code> is just set to -1 since it has no use in these types.</p>
<h2><a class="anchor" aria-hidden="true" id="message-subscription"></a><a href="#message-subscription" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Message Subscription</h2>
<p>Due to the nature of quick gossip, it's possible that a node might have just the hash and not the raw message yet at a particular point in time. In such cases, if the node receives a <code>PULL</code> message for that hash, it adds that node to a subscription list. As soon as the node receives the raw message for that hash, it then sends it out to all the peers in the subscription list.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#overview">Overview</a></li><li><a href="#interfaces">Interfaces</a><ul class="toc-headings"><li><a href="#initializerumormanager">InitializeRumorManager</a></li><li><a href="#spreadrumor">SpreadRumor</a></li><li><a href="#spreadforeignrumor">SpreadForeignRumor</a></li><li><a href="#stoprounds">StopRounds</a></li></ul></li><li><a href="#rumor-state-machine">Rumor State Machine</a></li><li><a href="#gossip-message-format">Gossip Message Format</a></li><li><a href="#optimized-pull-push-mechanism">Optimized Pull-Push Mechanism</a></li><li><a href="#message-subscription">Message Subscription</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/dev-portal/" class="nav-home"><img src="/dev-portal/img/zilliqa-logo_1zilliqa-logo.png" alt="Zilliqa Developer Portal" width="66" height="70"/></a><div><h5>Links</h5><a href="https://www.github.com/Zilliqa" target="_blank" rel="noreferrer noopener">GitHub</a><a href="https://blog.zilliqa.com/" target="_blank" rel="noreferrer noopener">Medium</a><a href="https://twitter.com/zilliqa" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://discord.gg/XMRE9tt" target="_blank" rel="noreferrer noopener">Discord</a><a href="https://www.youtube.com/channel/UCvinnFbf0u71cajoxKcfZIQ" target="_blank" rel="noreferrer noopener">YouTube</a></div></section><section class="copyright">Copyright © 2020 Zilliqa Research Pte. Ltd.</section></footer></div></body></html>