(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{209:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(2),s=n(9),o=(n(0),n(239)),r={id:"core-consensus",title:"Consensus"},i={id:"contributors/core-consensus",isDocsHomePage:!1,title:"Consensus",description:"This section describes how PBFT consensus (as initially designed in the Zilliqa whitepaper) is implemented and used in the core Zilliqa code.",source:"@site/docs/contributors/core-consensus.md",permalink:"/dev-portal/docs/contributors/core-consensus",editUrl:"https://github.com/Zilliqa/dev-portal/docs/contributors/core-consensus.md",sidebar:"ContributorsSidebar",previous:{title:"General Node Operation",permalink:"/dev-portal/docs/contributors/core-node-operation"},next:{title:"Multisignatures",permalink:"/dev-portal/docs/contributors/core-multisignatures"}},c=[{value:"Usage in the Protocol",id:"usage-in-the-protocol",children:[{value:"State Machine",id:"state-machine",children:[]},{value:"Two-Round Consensus",id:"two-round-consensus",children:[]},{value:"Consensus Subsets",id:"consensus-subsets",children:[]},{value:"Operational Parameters",id:"operational-parameters",children:[]}]}],l={rightToc:c};function b(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This section describes how PBFT consensus (as initially designed in the Zilliqa ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://docs.zilliqa.com/whitepaper.pdf"}),"whitepaper"),") is implemented and used in the core Zilliqa code."),Object(o.b)("h2",{id:"usage-in-the-protocol"},"Usage in the Protocol"),Object(o.b)("p",null,"Consensus is used in the following stages of the protocol:"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Data"),Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Members"),Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Timing"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"DS Block"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"DS committee"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"After PoW window")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Shard Microblock"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Shard nodes"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"After Tx processing by the shard nodes")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"DS Microblock + Tx Block"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"DS committee"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"After Tx processing by the DS nodes")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"VC Block"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"DS committee"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"After DS nodes enter into view change")))),Object(o.b)("h3",{id:"state-machine"},"State Machine"),Object(o.b)("p",null,"The consensus protocol is implemented across two classes: ",Object(o.b)("inlineCode",{parentName:"p"},"ConsensusLeader")," and ",Object(o.b)("inlineCode",{parentName:"p"},"ConsensusBackup"),". The diagram below shows the state transitions for both leader and backup."),Object(o.b)("p",null,Object(o.b)("img",Object(a.a)({parentName:"p"},{src:"../../assets/core/features/consensus-protocol/image01.jpg",alt:"image01"}))),Object(o.b)("h4",{id:"initial-state"},"Initial State"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"INITIAL")," state is set when the object for each class is first created (e.g., see ",Object(o.b)("inlineCode",{parentName:"p"},"DirectoryService::RunConsensusOnDSBlockWhenDSPrimary"),")."),Object(o.b)("h4",{id:"announcement-and-commitment-phase"},"Announcement and Commitment Phase"),Object(o.b)("p",null,"After instantiation, the node running the ",Object(o.b)("inlineCode",{parentName:"p"},"ConsensusLeader")," kicks off the sequence by sending out the announcement message. The announcement includes the data that all the peers need to reach consensus on. Each node running a ",Object(o.b)("inlineCode",{parentName:"p"},"ConsensusBackup")," then processes the announcement message, which also means running the validator function relevant to the type of consensus (e.g., ",Object(o.b)("inlineCode",{parentName:"p"},"DirectoryService::DSBlockValidator"),")."),Object(o.b)("p",null,"If the announcement is accepted, a commit is sent back to the leader. The leader stays in this phase until the required number of commits (2/3) is received from the backups (note that the leader itself is part of the 2/3+1 requirement laid out in the whitepaper)."),Object(o.b)("h4",{id:"challenge-and-response-phase"},"Challenge and Response Phase"),Object(o.b)("p",null,"After receiving the required number of commits, the leader generates the challenge, which is a function of the aggregated commits and public keys of everyone who committed (including the leader itself). The challenge is then sent out to the committed backups, who send back a response message afterwards."),Object(o.b)("h4",{id:"collective-signature-phase"},"Collective Signature Phase"),Object(o.b)("p",null,"Once all responses have been collected, the leader generates the collective signature, and sends out both the collective signature and the response map (which indicates who participated in both commit and response phases) to all peers. With this information, the backups can then verify the collective signature, and this effectively concludes the round of consensus."),Object(o.b)("h3",{id:"two-round-consensus"},"Two-Round Consensus"),Object(o.b)("p",null,"In actuality the state machine above represents just half of the PBFT consensus sequence. A full consensus requires running through the above phases in two rounds."),Object(o.b)("p",null,"There are a couple of differences between rounds. First, the announcement triggers the start of round 1. For round 2, the collective signature message serves as the trigger. Second, the message to co-sign in round 1 is the data that the user intends to be verified (e.g., DS Block). For round 2, the message to co-sign is that same data plus the collective signature and response map from round 1."),Object(o.b)("h3",{id:"consensus-subsets"},"Consensus Subsets"),Object(o.b)("p",null,"The consensus protocol was initially designed as a single linear sequence from ",Object(o.b)("inlineCode",{parentName:"p"},"INITIAL")," to ",Object(o.b)("inlineCode",{parentName:"p"},"DONE"),".  However, network instability inevitably would frequently lead to one or more view changes, slowing down the progress of the Mainnet."),Object(o.b)("p",null,"To address this situation, we changed the consensus implementation to support multiple concurrently running consensuses across different subsets of peers. This is how it works:"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},Object(o.b)("strong",{parentName:"p"},"Note"),": For the Mainnet we have set the number of subsets to 2 at the DS level and just 1 at the shard level. The steps below assume this count. Other counts are theoretically supported by the code but may not have been fully tested at this point.")),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Instead of immediately progressing after receiving the required 2/3 commits, the leader now waits for a maximum duration of ",Object(o.b)("inlineCode",{parentName:"p"},"COMMIT_WINDOW_IN_SECONDS")," seconds to receive commits. It cuts the waiting time short only if the percentage of peers specified by ",Object(o.b)("inlineCode",{parentName:"p"},"COMMIT_TOLERANCE_PERCENT")," has already committed. This is done for both rounds of consensus.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"Once the leader has stopped accepting commits, it generates two subsets out of the committed peers (both subsets are of size 2/3+1 and includes the leader):"),Object(o.b)("ul",{parentName:"li"},Object(o.b)("li",{parentName:"ul"},"Subset 0 = If consensus is within DS committee, prioritize DS guards, and fill in the remaining slots with other DS nodes. If consensus is within shard, nodes are randomly selected, with no bias towards guards."),Object(o.b)("li",{parentName:"ul"},"Subset 1 = Nodes are randomly selected, with no bias towards guards (regardless of whether consensus is done at DS or shard level)."))),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The leader creates two challenges and sends both to all backups who are part of at least one of the two subsets.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The backups validate both challenges and send back responses to both.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The leader goes through both responses from each backup and just picks out the ones for which the backup is part of the subset(s).")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The consensus round concludes once one of the two subsets has reached completion.")),Object(o.b)("li",{parentName:"ol"},Object(o.b)("p",{parentName:"li"},"The subsets are generated once again from the list of commits in the second round of consensus, and the same processing steps are followed thereafter."))),Object(o.b)("h3",{id:"operational-parameters"},"Operational Parameters"),Object(o.b)("p",null,"These are the relevant constants that affect the way our consensus operates:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"BROADCAST_GOSSIP_MODE")," - When this is ",Object(o.b)("inlineCode",{parentName:"p"},"true"),", ",Object(o.b)("inlineCode",{parentName:"p"},"ConsensusLeader")," sends the announcement and collective signature messages using gossip. Otherwise, the messages are sent using multicast.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"COMMIT_TOLERANCE_PERCENT")," - This specifies the percentage of the peers that are needed to send a commit to cut the waiting time (specified by ",Object(o.b)("inlineCode",{parentName:"p"},"COMMIT_WINDOW_IN_SECONDS"),") prematurely, if the subset count is more than 1.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"COMMIT_WINDOW_IN_SECONDS")," - This specifies the maximum duration the leader will wait to receive commits, if the subset count is more than 1.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"CONSENSUS_MSG_ORDER_BLOCK_WINDOW")," - This is used at the ",Object(o.b)("inlineCode",{parentName:"p"},"DirectoryService")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Node")," level to indicate the number of seconds the node will delay processing a particular consensus message that is not applicable to the current state of the consensus object (based on ",Object(o.b)("inlineCode",{parentName:"p"},"ConsensusCommon::CanProcessMessage()"),").")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"CONSENSUS_OBJECT_TIMEOUT")," - This is used at the ",Object(o.b)("inlineCode",{parentName:"p"},"DirectoryService")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Node")," level to indicate the number of seconds the node will delay processing a consensus message that is not applicable to the current state of the ",Object(o.b)("inlineCode",{parentName:"p"},"DirectoryService")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Node")," instance (e.g., a DS node may have received a view change consensus message while it is still not in the ",Object(o.b)("inlineCode",{parentName:"p"},"VIEWCHANGE_CONSENSUS")," state).")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"DS_NUM_CONSENSUS_SUBSETS")," - This indicates the number of consensus subsets to be used for consensus within the DS committee.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"SHARD_NUM_CONSENSUS_SUBSETS")," - This indicates the number of consensus subsets to be used for consensus within the shard."))))}b.isMDXComponent=!0},239:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),s=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=s.a.createContext({}),b=function(e){var t=s.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=b(e.components);return s.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},d=s.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=b(n),d=a,h=p["".concat(r,".").concat(d)]||p[d]||u[d]||o;return n?s.a.createElement(h,i(i({ref:t},l),{},{components:n})):s.a.createElement(h,i({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,r[1]=i;for(var l=2;l<o;l++)r[l]=n[l];return s.a.createElement.apply(null,r)}return s.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);