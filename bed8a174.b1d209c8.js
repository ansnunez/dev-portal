(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{212:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(2),i=n(9),r=(n(0),n(237)),o={id:"exchange-sending-transactions",title:"Sending Transactions"},s={id:"exchange-sending-transactions",isDocsHomePage:!1,title:"Sending Transactions",description:"---",source:"@site/docs/exchange-sending-transactions.md",permalink:"/docs/exchange-sending-transactions",editUrl:"https://github.com/Zilliqa/dev-portal/docs/exchange-sending-transactions.md",sidebar:"someSidebar4",previous:{title:"Account Management",permalink:"/docs/exchange-account-management"},next:{title:"Polling for Deposits",permalink:"/docs/exchange-tracking-deposits"}},c=[{value:"Constructing the Transaction Object",id:"constructing-the-transaction-object",children:[]},{value:"Signing the Transaction",id:"signing-the-transaction",children:[]},{value:"Sending the Transaction",id:"sending-the-transaction",children:[]}],l={rightToc:c};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("hr",null),Object(r.b)("p",null,"A critical feature of any exchange is the ability to withdraw the funds held\nin custody to an arbitrary address of the user's choosing. Because Zilliqa\nnodes do not provide an API for signing transactions on your behalf, you will\nhave to do so locally using an SDK of your choosing. We provide examples using\nzilliqa-js, the official JavaScript SDK."),Object(r.b)("p",null,"The code in this tutorial is derived from the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/Zilliqa/dev-portal/blob/master/examples/exchange/src/services/zilliqa.ts"}),"example application"),"."),Object(r.b)("h2",{id:"constructing-the-transaction-object"},"Constructing the Transaction Object"),Object(r.b)("p",null,"There are several ways to construct a ",Object(r.b)("inlineCode",{parentName:"p"},"Transaction")," instance. We recommend\nusing the transaction factory that is on the umbrella Zilliqa object, like\nso:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"import { Zilliqa } from '@zilliqa-js/zilliqa';\nconst api = 'https://community-api.aws.z7a.xyz';\nconst zilliqa = new Zilliqa(api);\nconst pubKey = '02bc475d1b5dd9d6ed6347e93da3d4c1ad35f4d987d52ea91de997ecba56845cd2';\n\nconst rawTx = zilliqa.transactions.new({\n  version: bytes.pack(2, 1),\n  amount,\n  nonce: 1\n  gasLimit: Long.fromNumber(1), // normal (non-contract) transactions cost 1 gas\n  gasPrice: new BN(units.toQa(1000, units.Units.Li)), // the minimum gas price is 1,000 li\n  toAddr: to, // toAddr is self-explanatory\n  pubKey, // this determines which account is used to send the tx\n});\n")),Object(r.b)("h2",{id:"signing-the-transaction"},"Signing the Transaction"),Object(r.b)("p",null,"Again, there are a few ways you can sign your transaction. Under the hood,\nsigning is done with the elliptic curve ",Object(r.b)("inlineCode",{parentName:"p"},"secp256k1"),". The easiest way to do\nthis is by using a wallet. Extending our example above:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"/* truncated */\nconst privateKey = '1CC85C5F4791232D7D9A6FC35F2FF15EFAAC4A6E0E9F4A565FD2CCCCB73FCA3B'\nconst address = 'e3ea87d7838397fc4417f5ec449f2d2d7cdb6dd1';\nzilliqa.wallet.addByPrivateKey(privateKey);\n// signWith uses the specified address to perform the signing of the transaction.\n// note that we provided the nonce to use when constructing the transaction.\n// if the nonce is not provided, zilliqa-js will automatically try to determine the correct nonce to use.\n// however, if there is no network connection, zilliqa-js will not be able to\n// do that, and signing will fail.\nconst signedTx = await this.zil.wallet.signWith(rawTx, address);\n")),Object(r.b)("p",null,"Note that we provided the nonce to use when constructing the transaction. If the nonce is not provided, zilliqa-js will automatically try to determine the correct nonce to use.\nHowever, if there is no network connection, zilliqa-js will not be able to do that, and signing will fail."),Object(r.b)("p",null,"If the ",Object(r.b)("inlineCode",{parentName:"p"},"Transaction")," is successfully signed, you will be able to access the\n",Object(r.b)("inlineCode",{parentName:"p"},"signature")," property on ",Object(r.b)("inlineCode",{parentName:"p"},"txParams"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"console.log(signedTx.txParams.signature) // 128-bit signature\n")),Object(r.b)("p",null,"At this stage, you'll be able to broadcast your newly-signed transaction to\nthe network through a seed node."),Object(r.b)("h2",{id:"sending-the-transaction"},"Sending the Transaction"),Object(r.b)("p",null,"Broadcasting a signed transaction is trivial, but involves some subtleties\nthat can trip you up if you do not have a deep understanding of Zilliqa's\narchitecture."),Object(r.b)("p",null,"We demonstrate a lower-level way to broadcast a transaction using the built-in\n",Object(r.b)("inlineCode",{parentName:"p"},"HTTPProvider"),", as follows:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"/* truncated */\nconst res = await this.zil.provider.send('CreateTransaction', tx.txParams);\n")),Object(r.b)("p",null,"This returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Promise")," that, if successful, will contain your transaction\nhash:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"console.log(res.result && res.result.TranID) // 32-byte transaction hash\n")),Object(r.b)("p",null,"However, note that ",Object(r.b)("inlineCode",{parentName:"p"},"result")," will not exist on the response if there is an\nerror in processing the transaction. Instead, the response will contain an\n",Object(r.b)("inlineCode",{parentName:"p"},"error")," key, which is an object that complies with JSON-RPC 2.0."),Object(r.b)("p",null,"If you receive a ",Object(r.b)("inlineCode",{parentName:"p"},"TranID"),", that means your transaction was accepted by the\nseed node, and is now pending. ",Object(r.b)("inlineCode",{parentName:"p"},"zilliqa-js")," provides a way to automatically\npoll the lookup for confirmation:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"// returns a Promise<Transaction>\n// in this case, we try polling the node 33 times, increasing the interval\n// between attempts by 1000ms each time. this works out roughly to the block\n// time on the Zilliqa main net.\nconst tx = await signedTx.confirm(res.result.TranID, 33, 1000)\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"confirm")," method returns a Promise the status of which signifies the\nconfirmation status of the transaction. If the transaction was confirmed:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"assert(signedTx.isConfirmed() === true);\n")))}d.isMDXComponent=!0},237:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),d=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=d(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=d(n),b=a,h=u["".concat(o,".").concat(b)]||u[b]||p[b]||r;return n?i.a.createElement(h,s(s({ref:t},l),{},{components:n})):i.a.createElement(h,s({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);